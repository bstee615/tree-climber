# Task 1-2: Implement def-use solver

## Description
Implement the iterative worklist algorithm for def-use chain analysis in the tree-sprawler project.

@Back to task list

## Status History
| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-06-14 10:00:00 | Created | N/A | Proposed | Initial task creation | system |
| 2025-06-14 11:30:00 | Status Change | Proposed | InProgress | Starting implementation | system |
| 2025-06-14 12:30:00 | Status Change | InProgress | Done | Implementation and tests complete | system |
| 2025-06-14 11:05:00 | Status Change | Proposed | InProgress | Starting implementation | system |

## Requirements
1. Implement DefUseAnalysis class in builder.py
2. Create worklist algorithm for iterative dataflow analysis
3. Implement reaching definitions analysis
4. Build def-use chains from analysis results
5. Handle loops and branches correctly
6. Integrate with existing CFG implementation

## Implementation Plan
1. Create DefUseAnalysis class with core methods:
   - analyze(cfg: List[CFGNode]) -> List[DefUseChain]
   - _initialize_worklist()
   - _process_node(node: CFGNode)
   - _find_reaching_definitions()
   - _build_def_use_chains()

2. Implement worklist algorithm:
   ```python
   def analyze(self, cfg: List[CFGNode]) -> List[DefUseChain]:
       worklist = self._initialize_worklist()
       while worklist:
           node = worklist.pop(0)
           changed = self._process_node(node)
           if changed:
               worklist.extend(successor for successor in node.successors)
   ```

3. Add reaching definitions analysis:
   - Track definitions that reach each program point
   - Handle kill/gen sets for assignments
   - Update reaching definitions across CFG edges

4. Build def-use chains:
   - For each use, find reaching definitions
   - Create DefUseChain objects
   - Optionally find paths between defs and uses

## Test Plan
1. Unit Tests:
   - Test worklist initialization and processing
   - Test reaching definitions analysis
   - Test chain construction

2. Integration Tests:
   ```python
   # Test with simple CFG
   def test_simple_cfg():
       cfg = build_cfg("x = 5; y = x + 1;")
       analyzer = DefUseAnalysis()
       chains = analyzer.analyze(cfg)
       assert len(chains) == 1
       assert chains[0].variable == "x"
   
   # Test with loop
   def test_loop_cfg():
       cfg = build_cfg("""
           sum = 0
           for i in range(10):
               sum = sum + i
       """)
       analyzer = DefUseAnalysis()
       chains = analyzer.analyze(cfg)
       assert any(chain.variable == "sum" for chain in chains)
   ```

3. Test Complex Cases:
   - Multiple definitions reaching a use
   - Loops with multiple iterations
   - Nested control flow
   - Dead code
   - Unreachable definitions

## Files Modified
- /home/benjis/Code/tree-sprawler/src/tree_sprawler/dataflow/builder.py

## Success Criteria
- [ ] Worklist algorithm implemented and working
- [ ] Reaching definitions analysis complete
- [ ] Def-use chains correctly identified
- [ ] All test cases passing
- [ ] Works with existing CFG implementation
- [ ] Handles loops and branches correctly
- [ ] Reasonable performance on typical code sizes
